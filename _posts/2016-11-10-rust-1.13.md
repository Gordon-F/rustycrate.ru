---
layout: post
categories: новости
title: "Анонс Rust 1.13"
author: The Rust Core Team (перевёл Александр Ирбис)
---

Команда разработчиков рада представить выпуск Rust 1.13.0. Rust - это систмный 
язык программирования, нацеленный на безопасную работу с памятью, скорость и
параллельное выполнение кода.

Как обычно, вы можете [установить Rust 1.13.0][install] с соответствующей страницы 
официального сайта и прочитать [детальные заметки о релизе 1.13.0][notes] на GitHub. 
Данный релиз включает в себя 1448 патчей.

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1130-2016-11-10


### Что нового в стабильной версии 1.13

Это был по-настоящему напряжённый сезон в Rust. Мы участвовали сразу в трёх конференциях 
за короткий промежуток времени, и параллельно продолжали работу. На подходе целая куча 
удивительных вещей, но в данном выпуске мы хотели бы выделить три новых свойства языка,
включая долгожданный оператор `?`, а также заметное продвижение в работе над ускорением
компиляции.

Выпуск содержит важные исправления уязвимостей в Cargo, которые зависят от curl и OpenSSL, 
опубликовавших недавно обновления безопасности.
Дополнительная информация в соответствующих анонсах [curl 7.51.0] и [OpenSSL 1.0.2j].

[curl 7.51.0]: https://curl.haxx.se/changes.html
[OpenSSL 1.0.2j]: https://www.openssl.org/news/secadv/20160922.txt


<!--cut-->


#### Оператор `?`

Rust приобрёл новый оператор `?`, который делает работу c ошибками значительно приятней,
убирая визуальный шум. Он делает это решая одну простую проблему. Для иллюстрации, 
предположим, у нас есть такой код для чтения данных из файла:

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("username.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
```

Код содержит два пути, которые могут завершиться ошибкой: открытие файла 
и чтение данных из него. Если в одном из них произойдёт сбой, нам нужно 
вернуть ошибку из функции `read_username_from_file`. Для этого нам 
приходится `match`ить результат операций ввода-вывода. Однако в таких простых случаях 
как этот, где мы просто пробрасываем ошибку вверх по стеку вызовов, использование `match` 
- это постоянно повторяющийся шаблонный код, не несущий полезной информации читающему его.

С `?` вышеприведённый код будет выглядеть так:

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("username.txt")?;
    let mut s = String::new();

    f.read_to_string(&mut s)?;

    Ok(s)
}
```

`?` яляется сокращением для целого выражения `match`, которое мы писали выше.
Другими словами, `?` применяется к значению типа `Result` и, если оно `Ok`, оно 
разворачивается и отдаётся вложенное значение. Если значение `Err`, то оно 
возвращается из текущей функции. Визуально это значительно более просто: вместо 
целого выражения мы теперь используем просто одиночный символ "?", чтобы отметить,
что здесь мы обрабатываем ошибку стандартным способом, передавая её вверх по стеку.

Бывалые ржависты могуть отметить, что это то же самое, что и макрос `try!`,
доступный ещё с Rust `1.0`. Действительно, это то же самое. До 1.13 
`read_username_from_file` могла быть реализована так: 

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = try!(File::open("username.txt"));
    let mut s = String::new();

    try!(f.read_to_string(&mut s));

    Ok(s)
}
```

Так зачем же вносить расширения в язык, если у нас уже есть макрос? Для этого есть 
разные причины. Во-первых, `try!` подтвердил свою исключительную полезность и часто 
используется в идиоматичном Rust. Он используется так часто, что мы думаем он стоит 
того, чтобы получить сладкий синтаксис. Такого рода эволюция является одним из больших
преимуществ мощной системы макросов: предполагаемые расширения синтаксиса языка могут
быть прототипированы и протестированы без изменения самого языка; в свою очередь, 
макрос, превратившийся в исключительно полезный, может указывать на недостающие 
особенности языка. Эта эволюция из `try!` в `?` отличный тому пример.

Одна из причин, по которым `try!` нуждается в подсахаривании - это то, что он крайне 
непривлекателен в случае многократного вызова в цепочке. Сравните:

```rust
try!(try!(try!(foo()).bar()).baz())
```

в противовес:

```rust
foo()?.bar()?.baz()?
```

Первый фрагмент достаточно сложно анализировать визуально, и каждый слой обработки 
ошибок приписывает в начало выражения вызов `try!`. Это требует чрезмерной 
концентрации внимания для тривиального проброса ошибок, затмевая основной рабочий
код, в данном примере вызовы `foo`, `bar`, `baz`. Данный тип выстраивания вызовов 
с обработчкой ошибок в цепочку характерен для таких ситуаций как применение паттерна
`builder`.

Наконец, специализированный синтаксис облегчит в будущем создание лучших сообщений 
об ошибках адаптированных к использованию `?`, в то время как создание качественных 
сообщений об ошибках в целом сильно затруднено с кодом, разворачиваемым из макросов
(в данном релизе, однако, сообщения об ошибках `?` могли бы использовать улучшение) 
\[TODO что значит "однако могли бы"?]

Хотя это маленькое улучшение, по нашему предыдущему опыту `?` выглядит как целостное
эргономичное улучшение для старого макроса `try!`. Это хороший пример разновидности 
последовательного усовершенствования качества жизни (quality-of-life improvement),
которые Rust продолжит получать, полируя неровности в нашем и без того мощном базовом 
языке (our already-powerful base language).


#### Макросы типов и атрибуты выражений (statement attributes)

TODO


#### Улучшение производительности

В последнее вермя много внимания было уделено производительности компилятора.
В данном выпуске - хорошие новости, и ещё больше - впереди.

Mark Simulacrum и Nick Cameron оттачивали [perf.rust-lang.org], наш инструмент для
отслеживания производительности компилятора. Он регулярно запускает [rustc-benchmarks]
на выделенном оборудовании и отслеживает изменения со временем. Этот инструмент
записывает результаты каждого этапа компиляции и используется разработчиками, чтобы
сузить диапазон поиска коммитов, приведших к деградации производительности. Это
важная часть нашего инструментария!

Мы можем воспользоваться им, чтобы взглянуть на [график][graph] производительности 
в период разработки 1.13 (показан ниже). Этот период охватывает даты с 16 августа 
по 29 сентября (однако график начинается с 25 августа и отфильтрован по нескольким 
критериям, чтобы исключить недостоверные, неполные или противоречивые результаты). 
Можно заметить большие сокращения, которые количественно отражены на соответствующей 
странице [статистики][statistics].

<br/>

![Performance graph](/images/2016-11-10-rust-1.13/graph.png)

<br/>

Значительное улучшение, показанное 1 сентября, произошло благодаря оптимизации Niko 
с [нормализованными проекциями кеша при трансляции][cache]. То есть, во время 
генерации в LLVM IR (промежуточное представление), компилятор больше не пересчитывает 
конкретные экземпляры связанных типов каждый раз как они потребуются, а повторно 
использует вычсленные в прошлый раз значения. Эта оптимизация вляет не на весь код, 
но в случае с кодом, в котором присутствуют определённые паттерны, как например 
в [futures-rs], где [время отладочной сборки улучшилось на 40%][ev1], разница будет 
заметна.

Другая подобная оптимизация, которая не затрагивает каждый крейт, но на некоторых
сказывается весьма заметно, сделана Michael Woerister, и улучшает время сборки
крейтов, которые экспортируют много [inline] функций. Если функция отмечена как 
`#[inline]`, в дополенние к трансляции этой функции для использования текущим 
крейтом, компилятор сохраняет её MIR представление в rlib крейта и транслирует
функцию в LLVM IR в каждом крейте, который вызывает её. Оптимизация Michael, если
смотреть назад, очевидна: в некоторых случаях инлайн-функции предназначены только 
для использования другими крейтами и никога не вызываются в крейте, их объявившем.
Поэтому компилятору не нужно транслировать код инлайн функций в определившем их
крейте _пока_ они не будут вызваны непосредственно. Это экономит rustc стоимость 
конвертации кода функций в LLVM IR и LLVM - оптимизиации и конвертации в машинный 
код.  

В некоторых случаях это даёт впечатляющие результаты. Время сборки ndarray 
[улучшилось на 50%][ev2], а для (неопубликованного) [winapi 0.3], rustc теперь 
не производит машинный код совсем.

Но подождите, это ещё не всё! Nick Nethercote также [обратил своё внимание 
на производительность компилятора][speed], сконцентрировавшись на профилировнии 
и микрооптимизациях. Данный релиз уже включает в себя [некоторые плоды его 
работы][fruit], другие готовятся в 1.14.  

Детальней в [заметках к релизу][notes].

[incremental compilation]: https://blog.rust-lang.org/2016/09/08/incremental.html
[fruit]: https://github.com/rust-lang/rust/blob/stable/RELEASES.md#compile-time-optimizations
[speed]: https://blog.mozilla.org/nnethercote/2016/10/14/how-to-speed-up-the-rust-compiler
[winapi 0.3]: https://github.com/retep998/winapi-rs
[ev1]: https://github.com/rust-lang/rust/pull/37600#issuecomment-258696690
[ev2]: https://github.com/rust-lang/rust/pull/37600#issuecomment-258706020
[futures-rs]: https://github.com/alexcrichton/futures-rs
[cache]: https://github.com/rust-lang/rust/pull/35761
[graph]: https://goo.gl/6T69T2
[statistics]: https://goo.gl/CLIAhi
[perf.rust-lang.org]: http://perf.rust-lang.org
[rustc-benchmarks]: https://github.com/rust-lang-nursery/rustc-benchmarks
[inline]: https://github.com/rust-lang/rust/pull/36524


#### Библиотека

* [Добавлены `assert_ne!` и `debug_assert_ne!`][35074]
* [`vec_deque::Drain`, `hash_map::Drain`, и `hash_set::Drain`
  теперь ковариантны][35354]
* [Реализован `AsRef<[T]>` для `std::slice::Iter`][35559]
* [Реализован `Debug` для `std::vec::IntoIter`][35707]
* [`CString`: avoid excessive growth just to 0-terminate][35871]
* [Реализован `CoerceUnsized` для `{Cell, RefCell, UnsafeCell}`][35627]
* [Использован arc4rand на FreeBSD][35884]
* [memrchr: корректное вычисление выравненных смещений][35969]
* [Улучшен Demangling идентификаторов Rust][36059]
* [Использовано монотонное время в переменных условий][35048]
* [Реализован `Debug` для `std::path::{Components,Iter}`][36101]
* [Реализованы типажи преобразования для `char`][35755]
* [Исправлен крах из-за переполнения при клонировании канала][36104]
* [Обнуление первого байта CString при drop][36264]
* [Проверка переполнения наследуется в sum и product][36372]
* [Добавлены недостающие реализации Eq][36423]
* [Реализован `Debug` для `DirEntry`][36631]
* [Когда `getaddrinfo` возвращает `EAI_SYSTEM` извлекается 
  актуальная ошибка из `errno`][36754]
* [`SipHasher`] устарел. Используйте [`DefaultHasher`].
* [Реализовано больше трейтов для `std::io::ErrorKind`][35911]
* [Оптимизирована проверка границ BinaryHeap][36072]
* [Обход проблемы алиасинга указателей в `Vec::extend_from_slice`,
  `extend_with_element`][36355]
* [Исправлена проверка переполнения для беззнакового pow()][34942]

[35074]: https://github.com/rust-lang/rust/pull/35074
[35074]: https://github.com/rust-lang/rust/pull/35074
[35354]: https://github.com/rust-lang/rust/pull/35354
[35559]: https://github.com/rust-lang/rust/pull/35559
[35707]: https://github.com/rust-lang/rust/pull/35707
[35871]: https://github.com/rust-lang/rust/pull/35871
[35627]: https://github.com/rust-lang/rust/pull/35627
[35884]: https://github.com/rust-lang/rust/pull/35884
[35969]: https://github.com/rust-lang/rust/pull/35969
[36059]: https://github.com/rust-lang/rust/pull/36059
[35048]: https://github.com/rust-lang/rust/pull/35048
[36101]: https://github.com/rust-lang/rust/pull/36101
[35755]: https://github.com/rust-lang/rust/pull/35755
[36104]: https://github.com/rust-lang/rust/pull/36104
[36264]: https://github.com/rust-lang/rust/pull/36264
[36372]: https://github.com/rust-lang/rust/pull/36372
[36423]: https://github.com/rust-lang/rust/pull/36423
[36631]: https://github.com/rust-lang/rust/pull/36631
[36754]: https://github.com/rust-lang/rust/pull/36754
[35911]: https://github.com/rust-lang/rust/pull/35911
[36072]: https://github.com/rust-lang/rust/pull/36072
[36355]: https://github.com/rust-lang/rust/pull/36355
[34942]: https://github.com/rust-lang/rust/pull/34942

Детальней в [заметках к релизу][notes].


#### Cargo

* [Обновлен OpenSSL до 1.0.2j][cargo/3121]
* [Обновлены curl и curl-sys][cargo/3241]
* [Добавлен флаг --all-features в cargo][cargo/3038]
* [Добавлены лицензия и файл лицензии вывод метаданных cargo][cargo/3110]
* [Не загружались зависимости для других платформ][cargo/3123]
* [Добавлена поддержка rustflags раздельно для платформ в .cargo/config][cargo/3157]
* [Избегание обновления реестра при добавлении зависимсотей][cargo/3144]
* [Задействованы рабочие пространства при `cargo install`][cargo/3146]
* [Добавлен флаг --message-format][cargo/3000]

[cargo/3021]: https://github.com/rust-lang/cargo/pull/3021
[cargo/3241]: https://github.com/rust-lang/cargo/pull/3241
[cargo/3038]: https://github.com/rust-lang/cargo/pull/3038
[cargo/3110]: https://github.com/rust-lang/cargo/pull/3110
[cargo/3123]: https://github.com/rust-lang/cargo/pull/3123
[cargo/3157]: https://github.com/rust-lang/cargo/pull/3157
[cargo/3144]: https://github.com/rust-lang/cargo/pull/3144
[cargo/3146]: https://github.com/rust-lang/cargo/pull/3146
[cargo/3000]: https://github.com/rust-lang/cargo/pull/3000

Детальней в [заметках к релизу][notes].


### Разработчики версии 1.13.0

155 человек внесли свой вклад в 1.13.0. Огромное вам спасибо!

{% spoiler Список участников %}

* Aaron Gallagher
* Abhishek Kumar
* aclarry
* Adam Medziński
* Ahmed Charles
* Aleksey Kladov
* Alexander von Gluck IV
* Alexandre Oliveira
* Alex Burka
* Alex Crichton
* Amanieu d'Antras
* Amit Levy
* Andrea Corradi
* Andre Bogus
* Andrew Cann
* Andrew Cantino
* Andrew Lygin
* Andrew Paseltiner
* Andy Russell
* Ariel Ben-Yehuda
* arthurprs
* Ashley Williams
* athulappadan
* Austin Hicks
* bors
* Brian Anderson
* c4rlo
* Caleb Jones
* CensoredUsername
* cgswords
* changchun.fan
* Chiu-Hsiang Hsu
* Chris Stankus
* Christopher Serr
* Chris Wong
* clementmiao
* Cobrand
* Corey Farwell
* Cristi Cobzarenco
* crypto-universe
* dangcheng
* Daniele Baracchi
* DarkEld3r
* David Tolnay
* Dustin Bensing
* Eduard Burtescu
* Eduard-Mihai Burtescu
* Eitan Adler
* Erik Uggeldahl
* Esteban Küber
* Eugene Bulkin
* Eugene R Gonzalez
* Fabian Zaiser
* Federico Ravasio
* Felix S. Klock II
* Florian Gilcher
* Gavin Baker
* Georg Brandl
* ggomez
* Gianni Ciccarelli
* Guillaume Gomez
* Jacob
* jacobpadkins
* Jake Goldsborough
* Jake Goulding
* Jakob Demler
* James Duley
* James Miller
* Jared Roesch
* Jared Wyles
* Jeffrey Seyfried
* JessRudder
* Joe Neeman
* Johannes Löthberg
* John Firebaugh
* johnthagen
* Jonas Schievink
* Jonathan Turner
* Jorge Aparicio
* Joseph Dunne
* Josh Triplett
* Justin LeFebvre
* Keegan McAllister
* Keith Yeung
* Keunhong Lee
* king6cong
* Knight
* knight42
* Kylo Ginsberg
* Liigo
* Manish Goregaokar
* Mark-Simulacrum
* Matthew Piziak
* Matt Ickstadt
* mcarton
* Michael Layne
* Michael Woerister
* Mikhail Modin
* Mohit Agarwal
* Nazım Can Altınova
* Neil Williams
* Nicholas Nethercote
* Nick Cameron
* Nick Platt
* Niels Sascha Reedijk
* Nikita Baksalyar
* Niko Matsakis
* Oliver Middleton
* Oliver Schneider
* orbea
* Panashe M. Fundira
* Patrick Walton
* Paul Fanelli
* philipp
* Phil Ruffwind
* Piotr Jawniak
* pliniker
* QuietMisdreavus
* Rahul Sharma
* Richard Janis Goldschmidt
* Scott A Carr
* Scott Olson
* Sean McArthur
* Sebastian Ullrich
* Sébastien Marie
* Seo Sanghyeon
* Sergio Benitez
* Shyam Sundar B
* silenuss
* Simonas Kazlauskas
* Simon Sapin
* Srinivas Reddy Thatiparthy
* Stefan Schindler
* Stephan Hügel
* Steve Klabnik
* Steven Allen
* Steven Fackler
* Terry Sun
* Thomas Garcia
* Tim Neumann
* Tobias Bucher
* Tomasz Miąsko
* trixnz
* Tshepang Lekhonkhobe
* Ulrich Weigand
* Ulrik Sverdrup
* Vadim Chugunov
* Vadim Petrochenkov
* Vanja Cosic
* Vincent Esche
* Wesley Wiser
* William Lee
* Ximin Luo
* Yossi Konstantinovsky
* zjhmale

{% endspoiler %}